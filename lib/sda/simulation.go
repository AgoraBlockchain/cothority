package sda

import (
	"errors"
	"github.com/BurntSushi/toml"
	"github.com/dedis/cothority/lib/dbg"
	"github.com/dedis/cothority/lib/network"
	"github.com/dedis/crypto/abstract"
	"github.com/dedis/crypto/config"
	"io/ioutil"
	"strconv"
	"strings"
	"time"
)

/*
Simulation is an interface needed by every protocol that wants to be available
to be used in a simulation.
*/

var simulationRegistered map[string]SimulationCreate

const SimulationFileName = "simulation.bin"

type SimulationCreate func(string) (Simulation, error)

type Simulation interface {
	// This has to initialise all necessary files and copy them to the
	// 'dir'-directory. This directory will be accessible to all simulated
	// hosts.
	// Setup also gets a alice of all available hosts. In turn it has
	// to return a tree using one or more of these hosts. It can create
	// the EntityList as desired, putting more than one Entity/Host on the same host.
	// The 'config'-argument holds all arguments read from the runfile in
	// toml-format.
	Setup(dir string, hosts []string) (*SimulationConfig, error)

	// Node will be run for every node and might be used to setup load-
	// creation. It is started once the Host is set up and running, but before
	// 'Run'
	Node(config *SimulationConfig) error

	// Run will begin with the simulation or return an error. It is sure
	// to be run on the host where 'tree.Root' is. It should only return
	// when all rounds are done.
	Run(config *SimulationConfig) error
}

// SimulationConfig has to be returned from 'Setup' and will be passed to
// 'Run'.
type SimulationConfig struct {
	// Represents the tree that has to be used
	Tree *Tree
	// The EntityList used by the tree
	EntityList *EntityList
	// All private keys generated by 'Setup', indexed by the complete addresses
	PrivateKeys map[string]abstract.Secret
	// If non-nil, points to our overlay
	Overlay *Overlay
	// If non-nil, points to our host
	Host *Host
	// Additional configuration used to run
	Config string
}

type SimulationConfigFile struct {
	TreeMarshal *TreeMarshal
	EntityList  *EntityList
	PrivateKeys map[string]abstract.Secret
	Config      string
}

// Load gets all configuration from dir + SimulationFileName and instantiates the
// corresponding host 'ha'.
func LoadSimulationConfig(dir, ha string) ([]*SimulationConfig, error) {
	network.RegisterMessageType(SimulationConfigFile{})
	bin, err := ioutil.ReadFile(dir + "/" + SimulationFileName)
	if err != nil {
		return nil, err
	}
	_, msg, err := network.UnmarshalRegisteredType(bin,
		network.DefaultConstructors(network.Suite))
	if err != nil {
		return nil, err
	}
	scf := msg.(SimulationConfigFile)
	sc := &SimulationConfig{
		EntityList:  scf.EntityList,
		PrivateKeys: scf.PrivateKeys,
		Config:      scf.Config,
	}
	sc.Tree, err = scf.TreeMarshal.MakeTree(sc.EntityList)
	if err != nil {
		return nil, err
	}

	ret := make([]*SimulationConfig, 0)
	if ha != "" {
		if !strings.Contains(ha, ":") {
			// to correctly match hosts a column is needed, else
			// 10.255.0.1 would also match 10.255.0.10 and others
			ha += ":"
		}
		for _, e := range sc.EntityList.List {
			for _, a := range e.Addresses {
				dbg.Lvl4("Searching for", ha, "in", a)
				// If we are started in Deterlab- or other
				// big-server-needs-multiple-hosts, we might
				// want to initialise all hosts in one instance
				// of 'cothority' so as to minimize memory
				// footprint
				if strings.Contains(a, ha) {
					dbg.Lvl3("Found host", a, "to match", ha)
					host := NewHost(e, scf.PrivateKeys[a])
					scNew := *sc
					scNew.Host = host
					scNew.Overlay = host.overlay
					ret = append(ret, &scNew)
				}

			}
		}
		if len(ret) == 0 {
			return nil, errors.New("Didn't find address: " + ha)
		}
	} else {
		ret = append(ret, sc)
	}
	return ret, nil
}

// Save takes everything in the SimulationConfig structure and saves it to
// dir + SimulationFileName
func (sc *SimulationConfig) Save(dir string) error {
	network.RegisterMessageType(&SimulationConfigFile{})
	scf := &SimulationConfigFile{
		TreeMarshal: sc.Tree.MakeTreeMarshal(),
		EntityList:  sc.EntityList,
		PrivateKeys: sc.PrivateKeys,
		Config:      sc.Config,
	}
	buf, err := network.MarshalRegisteredType(scf)
	if err != nil {
		dbg.Fatal(err)
	}
	err = ioutil.WriteFile(dir+"/"+SimulationFileName, buf, 0660)
	if err != nil {
		dbg.Fatal(err)
	}

	return nil
}

func SimulationRegister(name string, sim SimulationCreate) {
	if simulationRegistered == nil {
		simulationRegistered = make(map[string]SimulationCreate)
	}
	simulationRegistered[name] = sim
}

// NewSimulation returns a simulation and decodes the 'conf' into the
// simulation-structure
func NewSimulation(name string, conf string) (Simulation, error) {
	sim, ok := simulationRegistered[name]
	if !ok {
		return nil, errors.New("Didn't find simulation " + name)
	}
	simInst, err := sim(conf)
	if err != nil {
		return nil, err
	}
	_, err = toml.Decode(conf, simInst)
	if err != nil {
		return nil, err
	}
	return simInst, nil
}

type SimulationBFTree struct {
	Rounds     int
	BF         int
	Hosts      int
	SingleHost bool
}

// CreateEntityLists creates an EntityList with the host-names in 'addresses'.
// It creates 's.Hosts' entries, starting from 'port' for each round through
// 'addresses'
func (s *SimulationBFTree) CreateEntityList(sc *SimulationConfig, addresses []string, port int) {
	dbg.LLvl3("Starting to create entity List at " + time.Now().String())
	nbrAddr := len(addresses)
	if sc.PrivateKeys == nil {
		sc.PrivateKeys = make(map[string]abstract.Secret)
	}
	hosts := s.Hosts
	if s.SingleHost {
		// If we want to work with a single host, we only make one
		// host per server
		hosts = nbrAddr
	}
	if hosts > s.Hosts {
		hosts = s.Hosts
	}
	entities := make([]*network.Entity, hosts)
	dbg.Lvl3("Doing", hosts, "hosts")
	key := config.NewKeyPair(network.Suite)
	for c := 0; c < hosts; c++ {
		key.Secret.Add(key.Secret, key.Secret)
		key.Public.Mul(nil, key.Secret)
		address := addresses[c%nbrAddr] + ":" +
			strconv.Itoa(port+c/nbrAddr)
		entities[c] = network.NewEntity(key.Public, address)
		sc.PrivateKeys[entities[c].Addresses[0]] = key.Secret
	}
	sc.EntityList = NewEntityList(entities)
	dbg.LLvl3("Finished creating entity List at " + time.Now().String())
}

// Creates the tree as defined in SimulationBFTree and stores the result
// in 'sc'
func (s *SimulationBFTree) CreateTree(sc *SimulationConfig) error {
	dbg.LLvl3("Started creating tree at" + time.Now().String())
	if sc.EntityList == nil {
		return errors.New("Empty EntityList")
	}
	sc.Tree = sc.EntityList.GenerateBigNaryTree(s.BF, s.Hosts)
	dbg.LLvl3("Finished creating tree at" + time.Now().String())
	return nil
}

// Node - standard registers the entityList and the Tree with that Overlay,
// so we don't have to pass that around for the experiments.
func (s *SimulationBFTree) Node(sc *SimulationConfig) error {
	sc.Overlay.RegisterEntityList(sc.EntityList)
	sc.Overlay.RegisterTree(sc.Tree)
	return nil
}
