package sign

import (
	"bytes"
	"errors"
	"github.com/dedis/cothority/lib/coconet"
	dbg "github.com/dedis/cothority/lib/debug_lvl"
	"github.com/dedis/cothority/lib/hashid"
	"github.com/dedis/cothority/lib/proof"
	"github.com/dedis/crypto/abstract"
	"sort"
)

const FIRST_ROUND int = 1 // start counting rounds at 1

type MerkleStruct struct {
	// Message created by root. It can be empty and it will make no difference. In
	// the case of a timestamp service however we need the timestamp generated by
	// the round for this round . It will be included in the challenge, and then
	// can be verified by the client
	Msg []byte
	C   abstract.Secret // round lasting challenge
	R   abstract.Secret // round lasting response

	Log       SNLog // round lasting log structure
	HashedLog []byte

	R_hat abstract.Secret // aggregate of responses

	X_hat abstract.Point // aggregate of public keys

	Commits   []*SigningMessage
	Responses []*SigningMessage

	// own big merkle subtree
	MTRoot     hashid.HashId   // mt root for subtree, passed upwards
	Leaves     []hashid.HashId // leaves used to build the merkle subtre
	LeavesFrom []string        // child names for leaves

	// mtRoot before adding HashedLog
	LocalMTRoot hashid.HashId

	// merkle tree roots of children in strict order
	CMTRoots     []hashid.HashId
	CMTRootNames []string
	Proofs       map[string]proof.Proof
	Proof        []hashid.HashId
	PubKey       abstract.Point
	PrivKey      abstract.Secret
	Name         string

	// round-lasting public keys of children servers that did not
	// respond to latest commit or respond phase, in subtree
	ExceptionList []abstract.Point
	// combined point commits of children servers in subtree
	ChildV_hat map[string]abstract.Point
	// combined public keys of children servers in subtree
	ChildX_hat map[string]abstract.Point
	// for internal verification purposes
	ExceptionX_hat abstract.Point
	ExceptionV_hat abstract.Point

	BackLink hashid.HashId
	AccRound []byte

	Vote  *Vote
	Suite abstract.Suite

	Children map[string]coconet.Conn
	Parent   string
	View     int
}

type MerkleType int

const (
	EmptyRT MerkleType = iota
	ViewChangeRT
	AddRT
	RemoveRT
	ShutdownRT
	NoOpRT
	SigningRT
)

func NewMerkle(suite abstract.Suite) *MerkleStruct {
	merkle := &MerkleStruct{}
	merkle.Commits = make([]*SigningMessage, 0)
	merkle.Responses = make([]*SigningMessage, 0)
	merkle.ExceptionList = make([]abstract.Point, 0)
	merkle.Suite = suite
	merkle.Log.Suite = suite
	return merkle
}

// Sets up a round according to the needs stated in the
// Announcementmessage.
func MerkleSetup(sn *Node, view, RoundNbr int, am *AnnouncementMessage) error {
	sn.viewmu.Lock()
	if sn.ChangingView && am.Vote != nil && am.Vote.Vcv == nil {
		dbg.Lvl4(sn.Name(), "currently chaning view")
		sn.viewmu.Unlock()
		return ChangingViewError
	}
	sn.viewmu.Unlock()

	sn.roundmu.Lock()
	roundNbr := RoundNbr
	if roundNbr < sn.LastSeenRound {
		sn.roundmu.Unlock()
		return ErrPastRound
	}

	// make space for round type
	if len(sn.RoundTypes) <= roundNbr {
		sn.RoundTypes = append(sn.RoundTypes, make([]MerkleType, max(len(sn.RoundTypes), roundNbr+1))...)
	}
	if am.Vote == nil {
		dbg.Lvl4(roundNbr, len(sn.RoundTypes))
		sn.RoundTypes[roundNbr] = SigningRT
	} else {
		sn.RoundTypes[roundNbr] = MerkleType(am.Vote.Type)
	}
	sn.roundmu.Unlock()

	// set up commit and response channels for the new round
	merkle := NewMerkle(sn.suite)
	merkle.Vote = am.Vote
	merkle.Children = sn.Children(view)
	merkle.Parent = sn.Parent(view)
	merkle.View = view
	merkle.PubKey = sn.PubKey
	merkle.PrivKey = sn.PrivKey
	merkle.Name = sn.Name()
	merkle.InitCommitCrypto()
	sn.MerkleStructs[roundNbr] = merkle

	// update max seen round
	sn.roundmu.Lock()
	sn.LastSeenRound = max(sn.LastSeenRound, roundNbr)
	sn.roundmu.Unlock()

	// the root is the only node that keeps track of round # internally
	if sn.IsRoot(view) {
		sn.RoundsAsRoot += 1
		// TODO: is sn.Round needed if we have LastSeenRound
		sn.RoundNbr = roundNbr

		// Create my back link to previous round
		sn.SetBackLink(roundNbr)
		// sn.SetAccountableRound(Round)
	}
	return nil
}

func (rt MerkleType) String() string {
	switch rt {
	case EmptyRT:
		return "empty"
	case SigningRT:
		return "signing"
	case ViewChangeRT:
		return "viewchange"
	case AddRT:
		return "add"
	case RemoveRT:
		return "remove"
	case ShutdownRT:
		return "shutdown"
	case NoOpRT:
		return "noop"
	default:
		return ""
	}
}

/*
 * This is a module for the round-struct that does all the
 * calculation for a merkle-hash-tree.
 */

// Create round lasting secret and commit point v and V
// Initialize log structure for the round
func (merkle *MerkleStruct) InitCommitCrypto() {
	// generate secret and point commitment for this round
	rand := merkle.Suite.Cipher([]byte(merkle.Name))
	merkle.Log = SNLog{}
	merkle.Log.v = merkle.Suite.Secret().Pick(rand)
	merkle.Log.V = merkle.Suite.Point().Mul(nil, merkle.Log.v)
	// initialize product of point commitments
	merkle.Log.V_hat = merkle.Suite.Point().Null()
	merkle.Log.Suite = merkle.Suite
	merkle.Add(merkle.Log.V_hat, merkle.Log.V)

	merkle.X_hat = merkle.Suite.Point().Null()
	merkle.Add(merkle.X_hat, merkle.PubKey)
}

// Adds a child-node to the Merkle-tree and updates the root-hashes
func (merkle *MerkleStruct) MerkleAddChildren() {
	// children commit roots
	merkle.CMTRoots = make([]hashid.HashId, len(merkle.Leaves))
	copy(merkle.CMTRoots, merkle.Leaves)
	merkle.CMTRootNames = make([]string, len(merkle.Leaves))
	copy(merkle.CMTRootNames, merkle.LeavesFrom)

	// concatenate children commit roots in one binary blob for easy marshalling
	merkle.Log.CMTRoots = make([]byte, 0)
	for _, leaf := range merkle.Leaves {
		merkle.Log.CMTRoots = append(merkle.Log.CMTRoots, leaf...)
	}
}

// Adds the local Merkle-tree root, usually from a stamper or
// such
func (merkle *MerkleStruct) MerkleAddLocal(localMTroot hashid.HashId) {
	// add own local mtroot to leaves
	merkle.LocalMTRoot = localMTroot
	merkle.Leaves = append(merkle.Leaves, merkle.LocalMTRoot)
}

// Hashes the log of the round-structure
func (merkle *MerkleStruct) MerkleHashLog() error {
	var err error

	h := merkle.Suite.Hash()
	logBytes, err := merkle.Log.MarshalBinary()
	if err != nil {
		return err
	}
	h.Write(logBytes)
	merkle.HashedLog = h.Sum(nil)
	return err
}

func (merkle *MerkleStruct) ComputeCombinedMerkleRoot() {
	// add hash of whole log to leaves
	merkle.Leaves = append(merkle.Leaves, merkle.HashedLog)

	// compute MT root based on Log as right child and
	// MT of leaves as left child and send it up to parent
	sort.Sort(hashid.ByHashId(merkle.Leaves))
	left, proofs := proof.ProofTree(merkle.Suite.Hash, merkle.Leaves)
	right := merkle.HashedLog
	moreLeaves := make([]hashid.HashId, 0)
	moreLeaves = append(moreLeaves, left, right)
	merkle.MTRoot, _ = proof.ProofTree(merkle.Suite.Hash, moreLeaves)

	// Hashed Log has to come first in the proof; len(sn.CMTRoots)+1 proofs
	merkle.Proofs = make(map[string]proof.Proof, 0)
	for name := range merkle.Children {
		merkle.Proofs[name] = append(merkle.Proofs[name], right)
	}
	merkle.Proofs["local"] = append(merkle.Proofs["local"], right)

	// separate proofs by children (need to send personalized proofs to children)
	// also separate local proof (need to send it to timestamp server)
	merkle.SeparateProofs(proofs, merkle.Leaves)
}

// Identify which proof corresponds to which leaf
// Needed given that the leaves are sorted before passed to the function that create
// the Merkle Tree and its Proofs
func (merkle *MerkleStruct) SeparateProofs(proofs []proof.Proof, leaves []hashid.HashId) {
	// separate proofs for children servers mt roots
	for i := 0; i < len(merkle.CMTRoots); i++ {
		name := merkle.CMTRootNames[i]
		for j := 0; j < len(leaves); j++ {
			if bytes.Compare(merkle.CMTRoots[i], leaves[j]) == 0 {
				// sn.Proofs[i] = append(sn.Proofs[i], proofs[j]...)
				merkle.Proofs[name] = append(merkle.Proofs[name], proofs[j]...)
				continue
			}
		}
	}

	// separate proof for local mt root
	for j := 0; j < len(leaves); j++ {
		if bytes.Compare(merkle.LocalMTRoot, leaves[j]) == 0 {
			merkle.Proofs["local"] = append(merkle.Proofs["local"], proofs[j]...)
		}
	}
}

func (merkle *MerkleStruct) InitResponseCrypto() {
	merkle.R = merkle.Suite.Secret()
	merkle.R.Mul(merkle.PrivKey, merkle.C).Sub(merkle.Log.v, merkle.R)
	// initialize sum of children's responses
	merkle.R_hat = merkle.R
}

// Create Merkle Proof for local client (timestamp server) and
// store it in Node so that we can send it to the clients during
// the SignatureBroadcast
func (merkle *MerkleStruct) StoreLocalMerkleProof(chm *ChallengeMessage) error {
	proofForClient := make(proof.Proof, len(chm.Proof))
	copy(proofForClient, chm.Proof)

	// To the proof from our root to big root we must add the separated proof
	// from the localMKT of the client (timestamp server) to our root
	proofForClient = append(proofForClient, merkle.Proofs["local"]...)

	// if want to verify partial and full proofs
	if dbg.DebugVisible > 2 {
		//round.sn.VerifyAllProofs(view, chm, proofForClient)
	}
	merkle.Proof = proofForClient
	merkle.MTRoot = chm.MTRoot
	return nil
}

// Figure out which kids did not submit messages
// Add default messages to messgs, one per missing child
// as to make it easier to identify and add them to exception lists in one place
func (merkle *MerkleStruct) FillInWithDefaultMessages() []*SigningMessage {
	children := merkle.Children

	messgs := merkle.Responses
	allmessgs := make([]*SigningMessage, len(messgs))
	copy(allmessgs, messgs)

	for c := range children {
		found := false
		for _, m := range messgs {
			if m.From == c {
				found = true
				break
			}
		}

		if !found {
			allmessgs = append(allmessgs, &SigningMessage{View: merkle.View,
				Type: Default, From: c})
		}
	}

	return allmessgs
}

// Called by every node after receiving aggregate responses from descendants
func (merkle *MerkleStruct) VerifyResponses() error {

	// Check that: base**r_hat * X_hat**c == V_hat
	// Equivalent to base**(r+xc) == base**(v) == T in vanillaElGamal
	Aux := merkle.Suite.Point()
	V_clean := merkle.Suite.Point()
	V_clean.Add(V_clean.Mul(nil, merkle.R_hat), Aux.Mul(merkle.X_hat, merkle.C))
	// T is the recreated V_hat
	T := merkle.Suite.Point().Null()
	T.Add(T, V_clean)
	T.Add(T, merkle.ExceptionV_hat)

	var c2 abstract.Secret
	isroot := merkle.Parent == ""
	if isroot {
		// round challenge must be recomputed given potential
		// exception list
		msg := merkle.Msg
		msg = append(msg, []byte(merkle.MTRoot)...)
		merkle.C = HashElGamal(merkle.Suite, msg, merkle.Log.V_hat)
		c2 = HashElGamal(merkle.Suite, msg, T)
	}

	// intermediary nodes check partial responses aginst their partial keys
	// the root node is also able to check against the challenge it emitted
	if !T.Equal(merkle.Log.V_hat) || (isroot && !merkle.C.Equal(c2)) {
		return errors.New("Verifying ElGamal Collective Signature failed in " +
			merkle.Name)
	} else if isroot {
		dbg.Lvl4(merkle.Name, "reports ElGamal Collective Signature succeeded")
	}
	return nil
}

// Create Personalized Merkle Proofs for children servers
// Send Personalized Merkle Proofs to children servers
func (merkle *MerkleStruct) SendChildrenChallengesProofs(RoundNbr int, chm *ChallengeMessage) error {
	// proof from big root to our root will be sent to all children
	baseProof := make(proof.Proof, len(chm.Proof))
	copy(baseProof, chm.Proof)

	// for each child, create personalized part of proof
	// embed it in SigningMessage, and send it
	for name, conn := range merkle.Children {
		newChm := *chm
		newChm.Proof = append(baseProof, merkle.Proofs[name]...)

		var messg coconet.BinaryMarshaler
		messg = &SigningMessage{View: merkle.View, RoundNbr: RoundNbr, Type: Challenge, Chm: &newChm}

		// send challenge message to child
		// dbg.Lvl4("connection: sending children challenge proofs:", name, conn)
		if err := conn.PutData(messg); err != nil {
			return err
		}
	}

	return nil
}

// Send children challenges
func (merkle *MerkleStruct) SendChildrenChallenges(chm *ChallengeMessage) error {
	for _, child := range merkle.Children {
		var messg coconet.BinaryMarshaler
		messg = &SigningMessage{View: merkle.View, Type: Challenge, Chm: chm}

		if err := child.PutData(messg); err != nil {
			return err
		}
	}

	return nil
}

// Adding-function for crypto-points that accepts nil
func (r *MerkleStruct) Add(a abstract.Point, b abstract.Point) {
	if a == nil {
		a = r.Suite.Point().Null()
	}
	if b != nil {
		a.Add(a, b)
	}
}

// Substraction-function for crypto-points that accepts nil
func (r *MerkleStruct) Sub(a abstract.Point, b abstract.Point) {
	if a == nil {
		a = r.Suite.Point().Null()
	}
	if b != nil {
		a.Sub(a, b)
	}
}

func (r *MerkleStruct) IsRoot() bool {
	return r.Parent == ""
}

func (r *MerkleStruct) IsLeaf() bool {
	return len(r.Children) == 0
}
