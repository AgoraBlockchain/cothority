package main

import (
	"bufio"
	"errors"
	"flag"
	"fmt"
	"github.com/dedis/cothority/lib/app"
	dbg "github.com/dedis/cothority/lib/debug_lvl"
	"github.com/dedis/cothority/lib/graphs"
	"os"
	"strings"
)

var bf int
var configFile string = "config.toml"

func init() {
	flag.IntVar(&bf, "bf", 2, "Branching factor of the tree we must generate with BUILD")
	flag.StringVar(&configFile, "config", configFile, "Where to write the configuration file generated by BUILD (default = config.toml)")
}

// This file handles the creation a of cothority tree.
// Basically, it takes a list of files generated by the "key" command by each
// hosts and turn that into a full tree with the hostname and public key in each
// node.
// BuildTree takes a file formatted like this :
// host pubKey
// host2 pubKey
// ... ...
// For the moment it takes a branching factor on how to make the tree
// It writes the tree + any other configs to output using toml format
// with the app/config_conode.go struct
func Build(hostFile string) {

	// First, read the list of host and public keys
	hosts, pubs, err := readHostFile(hostFile)
	if err != nil {
		dbg.Fatal("Error reading the host file : ", err)
	}

	// Then construct the tree
	tree := constructTree(hosts, pubs, bf)

	// Then write the config
	conf := app.ConfigConode{
		Suite: suiteString,
		Tree:  tree,
	}

	app.WriteTomlConfig(conf, configFile)
	dbg.Lvl1("Written config file with tree to ", configFile)
}

// readHostFile will read the host file
// HOSTNAME PUBLICKEY
// for each line. and returns the whole set and any errror if any are found.
func readHostFile(file string) ([]string, []string, error) {
	// open it up
	hostFile, err := os.Open(file)
	if err != nil {
		return nil, nil, err
	}

	// Then read it up
	hosts := make([]string, 0)
	pubs := make([]string, 0)
	scanner := bufio.NewScanner(hostFile)
	ln := 0
	for scanner.Scan() {
		line := scanner.Text()
		ln += 1
		spl := strings.Split(line, " ")
		if len(spl) != 2 {
			return nil, nil, errors.New(fmt.Sprintf("Hostfile misformatted at line %s", ln))
		}
		// add it HOSTS -> PUBLIC KEY
		hosts = append(hosts, spl[0])
		pubs = append(pubs, spl[1])
	}
	dbg.Lvl1("Read the hosts files : ", ln, " entries")
	return hosts, pubs, nil
}

// ConstructTree takes a map of host -> public keys and a branching factor
// so it can constructs a regular tree. THe returned tree is the root
// it is constructed bfs style
func constructTree(hosts, pubs []string, bf int) *graphs.Tree {
	var root *graphs.Tree = new(graphs.Tree)
	root.Name = hosts[0]
	root.PubKey = pubs[0]
	var index int = 1
	bfs := make([]*graphs.Tree, 1)
	bfs[0] = root
	for len(bfs) > 0 && index < len(hosts) {
		t := bfs[0]
		t.Children = make([]*graphs.Tree, 0)
		lbf := 0
		// create space for enough children
		// init them
		for lbf < bf && index < len(hosts) {
			child := new(graphs.Tree)
			child.Name = hosts[index]
			child.PubKey = pubs[index]
			// append the children to the list of trees to visit
			bfs = append(bfs, child)
			t.Children = append(t.Children, child)
			index += 1
			lbf += 1
		}
		bfs = bfs[1:]
	}
	return root
}
